<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: release | Ethereum J]]></title>
  <link href="http://ethereumj.io/blog/categories/release/atom.xml" rel="self"/>
  <link href="http://ethereumj.io/"/>
  <updated>2016-02-14T21:27:10-05:00</updated>
  <id>http://ethereumj.io/</id>
  <author>
    <name><![CDATA[Roman Mandeleil]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Release: 1.1.0 pre homestead release]]></title>
    <link href="http://ethereumj.io/blog/2016/02/11/release-1-1-0/"/>
    <updated>2016-02-11T14:03:57-05:00</updated>
    <id>http://ethereumj.io/blog/2016/02/11/release-1-1-0</id>
    <content type="html"><![CDATA[<p>{% img right /images/posts/release-ilustration-1.gif Release 1.0.0-RC1 %}</p>

<p>That version is pre homestead version</p>

<p> Ethereum(J) is the library that can be embedded in any Java/Scala project
 and to provide full support for Ethereum protocol and sub services</p>

<h5>Pure Java Miner</h5>

<p>We support mining now! It is currently implemented in pure Java and can
be used in private and test networks. You may even mine on the live Ethereum
network however it is not economically feasible of course.</p>

<p>The miner can run in two modes ‘cache-only’ and ‘full-dataset’. For the same
difficulty the first one requires much more time to calculate a block nonce but
takes only 16Mb of RAM while the latter takes 1Gb but runs much faster. The
first one can be used for testing with lowered difficulty.</p>

<!--more-->


<p>The mining can be started by ‘mine.start’ config option which makes the miner started
either immediately on startup or when the blockchain is synced with the network. Another
option is starting the miner programmatically by invoking <code>Ethereum.getBlockMiner().startMining()</code>.
To monitor miner events you may want to implement and add <code>MinerListener</code></p>

<p>The <code>PrivateMinerSample</code> demonstrates creation of a simple 2 peer private network with a miner.
```</p>

<blockquote><p>gradlew run -PmainClass=org.ethereum.samples.PrivateMinerSample
```</p>

<h5>Eth protocol 61/62 support</h5></blockquote>

<p>This release remains in line with the whole Ethereum network where 95% of peers moved to the latest Eth62 subprotocol. The most significant improvement of the Eth62 protocol is more flexible block exchange messages which improves the sync speed.</p>

<h5>PendingState</h5>

<p>PendingState is when you can see the state change immediately after transaction submit instead of waiting for a block where your transaction is included.
For example if you send the value transfer transaction the PendingState will immediately reflect balance changes of sender and receiver (including mining fees) or indicates that transaction will not be accepted. This transaction is stored as a pending transaction until a new block is arrived. If the block contains that transaction it is removed from the PendingState, else the transaction is recalculated based on the latest block and you may see the updated state.</p>

<p>Try running <code>PendingStateSample</code> to see how it works on practice.
```</p>

<blockquote><p>gradlew run -PmainClass=org.ethereum.samples.PendingStateSample
```</p></blockquote>

<h5>Contract invocations becomes easier</h5>

<p>We have added utility classes to make the contract call transactions construction much easier. You may do this by either supplying a Solidity contract ABI or manually constructing each function by passing its name and input/output parameter types. You may pass functions arguments as a regular Java objects which are flexibly converted to Solidity types. The same way return values are parsed and represented as corresponding Java types.
The same way you may call constant function that is function invocation without propagating transaction to the network and without any changes to the contract state. So if you need to get some value from a contract you just do a constant call - that costs nothing, executed immediately and return you a value. To be completely precise you may call any function (not necessarily effectively constant) and get correct result but the contract state remains the same as before the call.</p>

<p>You may want to take a look at <code>PriceFeedSample</code> for introduction.
```</p>

<blockquote><p>gradlew run -PmainClass=org.ethereum.samples.PriceFeedSample
```</p></blockquote>

<h5>Finer and more flexible config</h5>

<p>There are much more options now on how to configure your EthereumJ instance.
For reference on all existing options, their description and defaults you may refer to the default config <code>ethereumj.conf</code> (you may find it in either the library jar or in the source tree <code>ethereum-core/src/main/resources</code>)
To override needed options you may use one of the following ways:</p>

<ul>
<li>put your options to the <code>&lt;working dir&gt;/config/ethereumj.conf file</code></li>
<li>put <code>user.conf</code> to the root of your classpath (as a resource)</li>
<li>put your options to any file and supply it via <code>-Dethereumj.conf.file=&lt;your config&gt;</code></li>
<li>programmatically by using <code>SystemProperties.CONFIG.override*()</code></li>
<li>programmatically using by overriding Spring <code>SystemProperties</code> bean</li>
</ul>


<p>Note that don’t need to put all the options to your custom config, just those you want to override.</p>

<h5>Running several nodes in a single JVM</h5>

<p>We removed the majority of statics in the EthereumJ code and substituted it with per Spring AppContext instances. That allows to create several separate instances of EthereumJ within a single JVM. So you can configure and start your small private network in a single JVM just from your main() method.</p>

<p>To see how that can be configured please refer to the <code>PrivateMinerSample</code>
```</p>

<blockquote><p>gradlew run -PmainClass=org.ethereum.samples.PrivateMinerSample
```</p></blockquote>

<h5>Whisper upgrade</h5>

<p>Whisper protocol has been upgraded to version 3 so if your private network supports Whisper you can use EthereumJ implementation together with the latest C++ Whisper capable nodes.</p>

<h5>Gas price calculator</h5>

<p>Pretty tiny but quite convenient feature which just gives you a reasonable gas price for your transaction. This value is just a statistics of the latest N transaction gas prices.</p>

<p>See how <code>PendingStateSample</code> uses that feature.
```</p>

<blockquote><p>gradlew run -PmainClass=org.ethereum.samples.PendingStateSample
```</p></blockquote>

<h5>Running EthereumJ</h5>

<h6>Adding as maven artifact to your project:</h6>

<p>{% codeblock Maven Snippet lang:xml <a href="https://gist.github.com/romanman/5f20d68d294ec1d049b5">https://gist.github.com/romanman/5f20d68d294ec1d049b5</a> %}<br/>
<repositories>
    <repository>
    <id>oss.jfrog.org</id>
    <name>Repository from Bintray</name>
    <url><a href="http://dl.bintray.com/ethereum/maven">http://dl.bintray.com/ethereum/maven</a></url>
    </repository>
</repositories></p>

<p><dependency>
  <groupId>org.ethereum</groupId>
  <artifactId>ethereumj-core</artifactId>
  <version>1.1.0-RELEASE</version>
  <type>pom</type>
</dependency>
{% endcodeblock %}</p>

<p>or gradle:</p>

<p>{% codeblock Gradle Snippet lang:groovy <a href="https://gist.github.com/romanman/55964ce71acdd9b51d8c">https://gist.github.com/romanman/55964ce71acdd9b51d8c</a> %}
   repositories {
       maven {
    url &ldquo;<a href="http://dl.bintray.com/ethereum/maven">http://dl.bintray.com/ethereum/maven</a>&rdquo;
       }
   }</p>

<p>   compile (&ldquo;org.ethereum:ethereumj-core:1.1.0-RELEASE&rdquo;)
{% endcodeblock %}</p>

<p>As a starting point for your own project take a look at <a href="https://github.com/ether-camp/ethereumj.starter">https://github.com/ether-camp/ethereumj.starter</a></p>

<h6>Running from command line:</h6>

<p>{% codeblock command line lang:bash <a href="https://gist.github.com/romanman/0bd6df410689af1a86b4">https://gist.github.com/romanman/0bd6df410689af1a86b4</a> %}
 git clone <a href="https://github.com/ethereum/ethereumj">https://github.com/ethereum/ethereumj</a>
 cd ethereumj
 gradlew run [-PmainClass=<sample class>]
{% endcodeblock %}</p>

<h6>Importing project to IntelliJ IDEA:</h6>

<p>{% codeblock command line lang:bash <a href="https://gist.github.com/romanman/ab27a4a0d879ded73aa3">https://gist.github.com/romanman/ab27a4a0d879ded73aa3</a> %}
 git clone <a href="https://github.com/ethereum/ethereumj">https://github.com/ethereum/ethereumj</a>
 cd ethereumj
 gradlew build
{% endcodeblock %}</p>

<p>  IDEA:
* File -> New -> Project from existing sources…
* Select <code>ethereumj/build.gradle</code>
* Dialog “Import Project from gradle”: press “OK”
* After building run either <code>org.ethereum.Start</code>, one of <code>org.ethereum.samples.*</code> or create your own main.</p>

<h5>Configuring EthereumJ</h5>

<p>For reference on all existing options, their description and defaults you may refer to the default config <code>ethereumj.conf</code> (you may find it in either the library jar or in the source tree <code>ethereum-core/src/main/resources</code>)
To override needed options you may use one of the following ways:</p>

<ul>
<li>put your options to the <code>&lt;working dir&gt;/config/ethereumj.conf</code> file</li>
<li>put <code>user.conf</code> to the root of your classpath (as a resource)</li>
<li>put your options to any file and supply it via <code>-Dethereumj.conf.file=&lt;your config&gt;</code></li>
<li>programmatically by using <code>SystemProperties.CONFIG.override*()</code></li>
<li>programmatically using by overriding Spring <code>SystemProperties</code> bean</li>
</ul>


<p>Note that don’t need to put all the options to your custom config, just those you want to override.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Release: 1.0.0-RC1]]></title>
    <link href="http://ethereumj.io/blog/2015/07/29/release-1-0-0-RC1/"/>
    <updated>2015-07-29T17:03:57-04:00</updated>
    <id>http://ethereumj.io/blog/2015/07/29/release-1-0-0-RC1</id>
    <content type="html"><![CDATA[<p>{% img right /images/posts/release-ilustration-1.gif Release 1.0.0-RC1 %}</p>

<p>That version is first of the RC series for Frontier network.</p>

<p> Ethereum(J) is the library that can be embedded in any Java/Scala project
 and to provide full support for Ethereum protocol and sub services.a</p>

<h5>Getting Started</h5>

<p>To get started and include a java library into your project all you need is
to <!--more--> use your favorite build system, here is Maven and Gradlle snippet:</p>

<p>{% codeblock Maven Snippet lang:xml <a href="https://gist.github.com/romanman/659e9e5b6b44b73b5755">https://gist.github.com/romanman/659e9e5b6b44b73b5755</a> %}<br/>
   <repositories>
     <repository>
       <id>oss.jfrog.org</id>
       <name>Repository from Bintray</name>
       <url><a href="http://dl.bintray.com/ethereum/maven">http://dl.bintray.com/ethereum/maven</a></url>
     </repository>
   </repositories></p>

<p>   <dependency>
     <groupId>org.ethereum</groupId>
     <artifactId>ethereumj-core</artifactId>
     <version>1.0.0-RC1</version>
     <type>zip</type>
   </dependency>
{% endcodeblock %}</p>

<p>or</p>

<p>{% codeblock Gradle Snippet lang:groovy <a href="https://gist.github.com/romanman/cc82a7a698f800040e10">https://gist.github.com/romanman/cc82a7a698f800040e10</a> %}</p>

<p>   repositories {
     maven {
      url &ldquo;<a href="http://dl.bintray.com/ethereum/maven">http://dl.bintray.com/ethereum/maven</a>&rdquo;
     }
    }</p>

<p>   compile (&ldquo;org.ethereum:ethereumj-core:1.0.0-RC1&rdquo;)
{% endcodeblock %}</p>

<p> Also we have very simple starter example - just do:
 <code>git clone https://github.com/ether-camp/ethereumj.starter</code>
   and you are ready to develop your first Ethereum application.
   Also it can be usefull to browse the code and study how ethereumj
   library is weaved into the application:
   <a href="https://github.com/ether-camp/ethereumj.starter">https://github.com/ether-camp/ethereumj.starter</a></p>

<p> <em>So, what is in:</em></p>

<h5>RLPx network layer for channel protection</h5>

<p>  Between each connected peers on the Ethereum network
  there is a security mechanism called RLPx - designed to provide
  an extremly protected channel by sophisticated encryption and decryption
  algorithm for all of the underlying traffic.</p>

<ul>
<li><code>org.ethereum.net.rlpx</code> - package providing full implementation for the RLPx protocol.</li>
</ul>


<h5>Peer Discovery</h5>

<p>  The peer discovery is Ethereum way to manage network topology and to provide the
  peer with best view of the network. Each peer tries over time to find best neighbours
  and to exchange information about sub protocols with them. That is beeing achieved
  by managing statistic table over the found peers by constant ongoing process.</p>

<ul>
<li><code>org.ethereum.net.rlpx.discover</code> - package providing full implementation for peer disovery protocol.</li>
</ul>


<h5>Multi Peer Blockchain Syncronization</h5>

<p>  The Ethereum protocol supports fast block chain download - using
  bittorent way of downloading multiple blocks simultaneously from different channels.</p>

<ul>
<li><code>org.ethereum.net.eth</code> - package providing full support of Eth subprotocol and multipeer blockschain synchronization</li>
</ul>


<h5>Full Ethereum VM Support</h5>

<p>  The heart of the Ethereum consensus protocol is the virtual machine.
  The virtual machines is running the contracts algorithms exactly the
  same way on all the peers, tested and compatible with all the implementations.</p>

<ul>
<li><code>org.ethereum.vm</code></li>
<li><code>org.ethereum.core</code> - packages providing full Ethereum virtual machine and consensys mechanism implementation</li>
</ul>


<h5>Ethereum Repository Updates and Manipulations</h5>

<p> The data structure that supports consensys validation
 algorithm, and eventually holding the full list of
 ethereum affairs is called Ethereum Repository.
 It makes masive use for Ethereum Trie data structure.
 More info about that magic Trie can be study <a href="/blog/2015/07/05/Ethereum-Trie/">here</a></p>

<ul>
<li><code>org.ethereum.repository</code> - package providing full Ethereum repository implementation</li>
</ul>


<h5>Testing Notes</h5>

<p> The EthereumJ librarey was tested on more than 830k blocks from POC-9 Olympics network and more than 7 million transactions, with final result of full consensus achieved.</p>

<p> The library supports 99% of compatabiltiy kit test cases. We support almost all test cases defined by
 Ethereum development group, the several adge cases that we formally do not support, which we decided to exclude
 at that stage for performance optimization.</p>

<h5>More Code Samples</h5>

<p> Another good place get started is to go and try code samples from our samples repository  <a href="https://github.com/ethereum/ethereumj/tree/develop/ethereumj-core/src/main/java/org/ethereum/samples">repository</a>
 you can run them right away after fetching them from the git.</p>
]]></content>
  </entry>
  
</feed>
